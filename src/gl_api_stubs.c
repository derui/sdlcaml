/*
  Implenmenting fundtions can't be generated by camlidl.
*/
#include <GL/gl.h>

#include <caml/mlvalues.h>
#include <caml/memory.h>
#include <caml/alloc.h>
#include <caml/fail.h>
#include <caml/callback.h>
#include <caml/bigarray.h>
#include "common.h"

#include "gl_enum_convert.h"
#include "gl_flags.h"

#define t_prim CAMLprim value

GLenum ml_camltype_to_gltype(value mltype) {
  CAMLparam1(mltype);
  GLenum type = -1;

  switch (mltype) {
    case MLTAG_Byte: type = GL_BYTE; break;
    case MLTAG_UByte: type = GL_UNSIGNED_BYTE; break;
    case MLTAG_Short: type = GL_SHORT; break;
    case MLTAG_UShort: type = GL_UNSIGNED_SHORT; break;
    case MLTAG_Int: type = GL_INT; break;
    case MLTAG_UInt: type = GL_UNSIGNED_INT; break;
    case MLTAG_Float: type = GL_FLOAT; break;
    case MLTAG_Double: type = GL_DOUBLE; break;
    case MLTAG_UByte2: type = GL_2_BYTES; break;
    case MLTAG_UByte3: type = GL_3_BYTES; break;
    case MLTAG_UByte4: type = GL_4_BYTES; break;
    default: break;
  }

  CAMLreturnT(GLenum, type);
}

value ml_camltype_from_gltype(GLenum type) {
  CAMLparam0();

  switch (type) {
    case GL_BYTE:           CAMLreturn(MLTAG_Byte);
    case GL_UNSIGNED_BYTE:  CAMLreturn(MLTAG_UByte);
    case GL_SHORT:          CAMLreturn(MLTAG_Short);
    case GL_UNSIGNED_SHORT: CAMLreturn(MLTAG_UShort);
    case GL_INT:            CAMLreturn(MLTAG_Int);
    case GL_UNSIGNED_INT:   CAMLreturn(MLTAG_UInt);
    case GL_FLOAT:          CAMLreturn(MLTAG_Float);
    case GL_DOUBLE:         CAMLreturn(MLTAG_Double);
    case GL_2_BYTES:        CAMLreturn(MLTAG_UByte2);
    case GL_3_BYTES:        CAMLreturn(MLTAG_UByte3);
    case GL_4_BYTES:        CAMLreturn(MLTAG_UByte4);
    default: CAMLreturn(Val_unit);
  }
}

value ml_store_array_as_type(void* array, int size, int array_type) {
  CAMLparam0();
  CAMLlocal1(ml_array);
  ml_array = caml_alloc(size, 0);

  switch (array_type) {
    case BIGARRAY_SINT8:
    case BIGARRAY_UINT8: {
      char* array_p = (char*)array;
      for (int i = 0; i < size; ++i) {
        Store_field(ml_array, i, Val_int(array_p[i]));
      }
      break;
    }
    case BIGARRAY_SINT16:
    case BIGARRAY_UINT16:
    case BIGARRAY_CAML_INT: {
      int* array_p = (int*) array;
      for (int i = 0; i < size; ++i) {
        Store_field(ml_array, i, Val_int(array_p[i]));
      }
      break;
    }
    case BIGARRAY_INT32: {
      unsigned int *array_p = (unsigned int*)array;
      for (int i = 0; i < size; ++i) {
      Store_field(ml_array, i, caml_copy_int32(array_p[i]));
      }
      break;
    }
    case BIGARRAY_INT64: {
      long long* array_p = (long long*)array;
      for (int i = 0; i < size; ++i) {
      Store_field(ml_array, i, caml_copy_int64(array_p[i]));
      }

      break;
    }
    case BIGARRAY_FLOAT32:{
      float * array_p = (float*)array;
      for (int i = 0; i < size; ++i) {
        Store_field(ml_array, i, caml_copy_double(array_p[i]));
      }
      break;
    }
    case BIGARRAY_FLOAT64: {
      double * array_p = (double*)array;
      for (int i = 0; i < size; ++i) {
        Store_field(ml_array, i, caml_copy_double(array_p[i]));
      }
      break;
  }
  }
  CAMLreturn(ml_array);
}

/* Caution!: pointer returned from this function must be freed by
   user!
*/
void* ml_malloc_array_by_datatype(GLenum type, int size) {
  switch (type) {
    case GL_UNSIGNED_BYTE_3_3_2:
    case GL_UNSIGNED_BYTE_2_3_3_REV:
    case GL_UNSIGNED_BYTE:
      return malloc(sizeof(unsigned char) * size);

    case GL_BYTE:
      return malloc(sizeof(char) * size);
    case GL_BITMAP:
      return malloc(sizeof(unsigned int) * size);
    case GL_UNSIGNED_SHORT_5_6_5:
    case GL_UNSIGNED_SHORT_5_6_5_REV:
    case GL_UNSIGNED_SHORT_4_4_4_4:
    case GL_UNSIGNED_SHORT_4_4_4_4_REV:
    case GL_UNSIGNED_SHORT_5_5_5_1:
    case GL_UNSIGNED_SHORT_1_5_5_5_REV:
    case GL_UNSIGNED_SHORT:
      return malloc(sizeof(unsigned short) * size);
    case GL_SHORT:
      return malloc(sizeof(short) * size);
    case GL_UNSIGNED_INT_8_8_8_8:
    case GL_UNSIGNED_INT_8_8_8_8_REV:
    case GL_UNSIGNED_INT_10_10_10_2:
    case GL_UNSIGNED_INT_2_10_10_10_REV:
    case GL_UNSIGNED_INT:
      return malloc(sizeof(unsigned int) * size);
    case GL_INT:
      return malloc(sizeof(int) * size);
    case GL_FLOAT:
      return malloc(sizeof(float) * size);
  }
  return NULL;
}

int ml_mapping_datatype_to_bigarray_type(GLenum type) {
  switch (type) {
    case GL_UNSIGNED_BYTE_3_3_2:
    case GL_UNSIGNED_BYTE_2_3_3_REV:
    case GL_UNSIGNED_BYTE:
      return BIGARRAY_UINT8;
    case GL_BYTE:
      return BIGARRAY_SINT8;
    case GL_BITMAP:
      return BIGARRAY_INT32;
    case GL_UNSIGNED_SHORT_5_6_5:
    case GL_UNSIGNED_SHORT_5_6_5_REV:
    case GL_UNSIGNED_SHORT_4_4_4_4:
    case GL_UNSIGNED_SHORT_4_4_4_4_REV:
    case GL_UNSIGNED_SHORT_5_5_5_1:
    case GL_UNSIGNED_SHORT_1_5_5_5_REV:
    case GL_UNSIGNED_SHORT:
      return BIGARRAY_UINT16;
    case GL_SHORT:
      return BIGARRAY_SINT16;
    case GL_UNSIGNED_INT_8_8_8_8:
    case GL_UNSIGNED_INT_8_8_8_8_REV:
    case GL_UNSIGNED_INT_10_10_10_2:
    case GL_UNSIGNED_INT_2_10_10_10_REV:
    case GL_UNSIGNED_INT:
      return BIGARRAY_INT32;
    case GL_INT:
      return BIGARRAY_CAML_INT;
    case GL_FLOAT:
      return BIGARRAY_FLOAT32;
  }
  return 0;
}

/* Function implementations */

t_prim gl_api_glCallLists(value n, value lists) {
  CAMLparam2(n, lists);
  GLenum type = ml_camltype_to_gltype(Field(lists, 0));

  value ary = Field(lists, 1);
  glCallLists(Int_val(n), type,
              (const void*)(Data_bigarray_val(ary)));
  CAMLreturn(Val_unit);
}

t_prim gl_api_glVertexPointer(value size, value stride, value pointer) {
  CAMLparam3(size, stride, pointer);

  GLenum type = ml_camltype_to_gltype(Field(pointer, 0));
  glVertexPointer(Int_val(size), type, Int_val(stride),
                  Data_bigarray_val(Field(pointer, 1)));

  CAMLreturn(Val_unit);
}

t_prim gl_api_glNormalPointer(value stride, value pointer) {
  CAMLparam2(stride, pointer);

  glNormalPointer(ml_camltype_to_gltype(Field(pointer, 0)),
                  Int_val(stride),
                  (const void*)(Data_bigarray_val(Field(pointer, 0))));
  CAMLreturn(Val_unit);
}

t_prim gl_api_glColorPointer(value size, value stride, value pointer) {
  CAMLparam3(size, stride, pointer);

  glColorPointer(Int_val(size),
                 ml_camltype_to_gltype(Field(pointer, 0)),
                 Int_val(stride),
                 (const void*)(Data_bigarray_val(Field(pointer, 1))));
  CAMLreturn(Val_unit);
}

t_prim gl_api_glIndexPointer(value stride, value pointer) {
  CAMLparam2(stride, pointer);

  glIndexPointer(ml_camltype_to_gltype(Field(pointer, 0)),
                 Int_val(stride),
                 (const void*)(Data_bigarray_val(Field(pointer, 0))));
  CAMLreturn(Val_unit);
}

t_prim gl_api_glTexCoordPointer(value size, value stride, value pointer) {
  CAMLparam3(size, stride, pointer);

  glTexCoordPointer(Int_val(size),
                    ml_camltype_to_gltype(Field(pointer, 0)),
                    Int_val(stride),
                    (const void*)(Data_bigarray_val(Field(pointer, 1))));
  CAMLreturn(Val_unit);
}

t_prim gl_api_glEdgeFlagPointer(value stride, value bool_array) {
  CAMLparam2(stride, bool_array);

  glEdgeFlagPointer(Int_val(stride),
                    Data_bigarray_val(Field(bool_array, 1)));
  CAMLreturn(Val_unit);
}

t_prim gl_api_glGetPointerv(value type) {
  CAMLparam1(type);
  CAMLlocal1(barray);

  GLenum pointer_type = glenum_ml_to_c(type);
  GLenum type_array = 0;
  long size = 0;

  switch (pointer_type) {
    case GL_COLOR_ARRAY_POINTER:
      glGetIntegerv(GL_COLOR_ARRAY_TYPE, (GLint*)&type_array);
      glGetIntegerv(GL_COLOR_ARRAY_SIZE, (GLint*)&size);
      break;
    case GL_EDGE_FLAG_ARRAY_POINTER:
      type_array = GL_INT;
      size = 1;
      break;
    case GL_FOG_COORD_ARRAY_POINTER:
      glGetIntegerv(GL_FOG_COORD_ARRAY_TYPE, (GLint*)&type_array);
      size = 1;
      break;
    case GL_FEEDBACK_BUFFER_POINTER:
      glGetIntegerv(GL_FEEDBACK_BUFFER_SIZE, (GLint*)&size);
      glGetIntegerv(GL_FEEDBACK_BUFFER_TYPE, (GLint*)&type_array);
      break;
    case GL_INDEX_ARRAY_POINTER:
      glGetIntegerv(GL_INDEX_ARRAY_TYPE, (GLint*)&type_array);
      size = 1;
      break;
    case GL_NORMAL_ARRAY_POINTER:
      glGetIntegerv(GL_NORMAL_ARRAY_TYPE, (GLint*)&type_array);
      size = 3;
      break;
    case GL_SECONDARY_COLOR_ARRAY_POINTER:
      glGetIntegerv(GL_SECONDARY_COLOR_ARRAY_SIZE, (GLint*)&size);
      glGetIntegerv(GL_SECONDARY_COLOR_ARRAY_TYPE, (GLint*)&type_array);
      break;
    case GL_SELECTION_BUFFER_POINTER:
      glGetIntegerv(GL_SELECTION_BUFFER_SIZE, (GLint*)&size);
      type = GL_UNSIGNED_INT;
      break;
    case GL_TEXTURE_COORD_ARRAY_POINTER:
      glGetIntegerv(GL_TEXTURE_COORD_ARRAY_SIZE, (GLint*)&size);
      glGetIntegerv(GL_TEXTURE_COORD_ARRAY_TYPE, (GLint*)&type_array);
      break;
    case GL_VERTEX_ARRAY_POINTER:
      glGetIntegerv(GL_VERTEX_ARRAY_SIZE, (GLint*)&size);
      glGetIntegerv(GL_VERTEX_ARRAY_TYPE, (GLint*)&type_array);
      break;
  }

  int bigarray_type = 0;
  switch (type_array) {
    case GL_BYTE:           bigarray_type = BIGARRAY_SINT8; break;
    case GL_UNSIGNED_BYTE:  bigarray_type = BIGARRAY_UINT8; break;
    case GL_SHORT:          bigarray_type = BIGARRAY_SINT16; break;
    case GL_UNSIGNED_SHORT: bigarray_type = BIGARRAY_UINT16; break;
    case GL_INT:            bigarray_type = BIGARRAY_CAML_INT; break;
    case GL_UNSIGNED_INT:   bigarray_type = BIGARRAY_INT32; break;
    case GL_FLOAT:          bigarray_type = BIGARRAY_FLOAT32; break;
    case GL_DOUBLE:         bigarray_type = BIGARRAY_FLOAT64; break;
    case GL_2_BYTES:        bigarray_type = BIGARRAY_SINT8; break;
    case GL_3_BYTES:        bigarray_type = BIGARRAY_SINT8; break;
    case GL_4_BYTES:        bigarray_type = BIGARRAY_SINT8; break;
  }

  void* pointer = NULL;
  glGetPointerv(pointer_type, &pointer);
  barray = alloc_bigarray(bigarray_type | BIGARRAY_C_LAYOUT,
                          1, pointer, (long*)&size);
  CAMLreturn(barray);
}

t_prim gl_api_glDrawElements(value mode, value count, value indices) {
  CAMLparam3(mode, count, indices);

  GLenum gl_mode = glenum_ml_to_c(mode);
  GLenum type = ml_camltype_to_gltype(Field(indices, 0));

  glDrawElements(gl_mode, Int_val(count), type,
                 Data_bigarray_val(Field(indices, 1)));
  CAMLreturn(Val_unit);
}

t_prim gl_api_glGetLightfv(value light, value pname) {
  CAMLparam2(light, pname);
  CAMLlocal1(val_single);

  GLenum gl_pname = glenum_ml_to_c(pname);
  switch (gl_pname) {
    case GL_AMBIENT:
    case GL_DIFFUSE:
    case GL_SPECULAR:
    case GL_POSITION: {
      const int size = 4;
      float val[size];
      glGetLightfv(glenum_ml_to_c(light),
                   gl_pname,
                   val);
      value caml_val[size];
      for (int i = 0; i < size; ++i) {
        caml_val[i] = caml_copy_double(val[i]);
      }
      CAMLreturn(array_from_c(caml_val, size));
    }
    case GL_SPOT_DIRECTION: {
      const int size = 3;
      float val[size];
      glGetLightfv(glenum_ml_to_c(light),
                   gl_pname,
                   val);
      value caml_val[size];
      for (int i = 0; i < size; ++i) {
        caml_val[i] = caml_copy_double(val[i]);
      }
      CAMLreturn(array_from_c(caml_val, size));
    }
    case GL_SPOT_EXPONENT:
    case GL_SPOT_CUTOFF:
    case GL_CONSTANT_ATTENUATION:
    case GL_LINEAR_ATTENUATION:
    case GL_QUADRATIC_ATTENUATION: {
      float val;
      glGetLightfv(glenum_ml_to_c(light),
                   gl_pname,
                   &val);
      val_single = caml_alloc(1, 0);
      Store_field(val_single, 0, caml_copy_double(val));
      CAMLreturn(val);
    }
    default: {
      val_single = caml_alloc(0, 0);
      CAMLreturn(val_single);
    }
  }
}

t_prim gl_api_glGetLightiv(value light, value pname) {
  CAMLparam2(light, pname);
  CAMLlocal1(val_single);

  GLenum gl_pname = glenum_ml_to_c(pname);
  switch (gl_pname) {
    case GL_AMBIENT:
    case GL_DIFFUSE:
    case GL_SPECULAR:
    case GL_POSITION: {
      const int size = 4;
      int val[size];
      glGetLightiv(glenum_ml_to_c(light),
                   gl_pname,
                   val);
      value caml_val[size];
      for (int i = 0; i < size; ++i) {
        caml_val[i] = Val_int(val[i]);
      }
      CAMLreturn(array_from_c(caml_val, size));
    }
    case GL_SPOT_DIRECTION: {
      const int size = 3;
      int val[size];
      glGetLightiv(glenum_ml_to_c(light),
                   gl_pname,
                   val);
      value caml_val[size];
      for (int i = 0; i < size; ++i) {
        caml_val[i] = Val_int(val[i]);
      }
      CAMLreturn(array_from_c(caml_val, size));
    }
    case GL_SPOT_EXPONENT:
    case GL_SPOT_CUTOFF:
    case GL_CONSTANT_ATTENUATION:
    case GL_LINEAR_ATTENUATION:
    case GL_QUADRATIC_ATTENUATION: {
      int val;
      glGetLightiv(glenum_ml_to_c(light),
                   gl_pname,
                   &val);
      val_single = caml_alloc(1, 0);
      Store_field(val_single, 0, Val_int(val));
      CAMLreturn(val);
    }
    default: {
      val_single = caml_alloc(0, 0);
      CAMLreturn(val_single);
    }
  }
}

t_prim gl_api_glGetMaterialfv(value face, value pname) {
  CAMLparam2(face, pname);
  CAMLlocal1(val_single);

  GLenum gl_pname = glenum_ml_to_c(pname);
  switch (gl_pname) {
    case GL_AMBIENT:
    case GL_DIFFUSE:
    case GL_SPECULAR:
    case GL_EMISSION: {
      const int size = 4;
      float val[size];
      glGetMaterialfv(glenum_ml_to_c(face),
                      gl_pname,
                      val);
      value caml_val[size];
      for (int i = 0; i < size; ++i) {
        caml_val[i] = caml_copy_double(val[i]);
      }
      CAMLreturn(array_from_c(caml_val, size));
    }
    case GL_COLOR_INDEXES: {
      const int size = 3;
      float val[size];
      glGetMaterialfv(glenum_ml_to_c(face),
                      gl_pname,
                      val);
      value caml_val[size];
      for (int i = 0; i < size; ++i) {
        caml_val[i] = caml_copy_double(val[i]);
      }
      CAMLreturn(array_from_c(caml_val, size));
    }
    case GL_SHININESS: {
      float val;
      glGetMaterialfv(glenum_ml_to_c(face),
                      gl_pname,
                      &val);
      val_single = caml_alloc(1, 0);
      Store_field(val_single, 0, caml_copy_double(val));
      CAMLreturn(val);
    }
    default: {
      val_single = caml_alloc(0, 0);
      CAMLreturn(val_single);
    }
  }
}

t_prim gl_api_glGetMaterialiv(value face, value pname) {
  CAMLparam2(face, pname);
  CAMLlocal1(val_single);

  GLenum gl_pname = glenum_ml_to_c(pname);
  switch (gl_pname) {
    case GL_AMBIENT:
    case GL_DIFFUSE:
    case GL_SPECULAR:
    case GL_EMISSION: {
      const int size = 4;
      int val[size];
      glGetMaterialiv(glenum_ml_to_c(face),
                      gl_pname,
                      val);
      value caml_val[size];
      for (int i = 0; i < size; ++i) {
        caml_val[i] = Val_int(val[i]);
      }
      CAMLreturn(array_from_c(caml_val, size));
    }
    case GL_COLOR_INDEXES: {
      const int size = 3;
      int val[size];
      glGetMaterialiv(glenum_ml_to_c(face),
                      gl_pname,
                      val);
      value caml_val[size];
      for (int i = 0; i < size; ++i) {
        caml_val[i] = Val_int(val[i]);
      }
      CAMLreturn(array_from_c(caml_val, size));
    }
    case GL_SHININESS: {
      int val;
      glGetMaterialiv(glenum_ml_to_c(face),
                      gl_pname,
                      &val);
      val_single = caml_alloc(1, 0);
      Store_field(val_single, 0, Val_int(val));
      CAMLreturn(val);
    }
    default: {
      val_single = caml_alloc(0, 0);
      CAMLreturn(val_single);
    }
  }
}

t_prim gl_api_glReadPixels_native(value x, value y, value width, value height, value format, value type) {
  CAMLparam5(x, y, width, height, format);
  CAMLxparam1(type);
  CAMLlocal1(barray);

  int size = 0;
  switch (glenum_ml_to_c(format)) {
    case GL_COLOR_INDEX:
    case GL_STENCIL_INDEX:
    case GL_DEPTH_COMPONENT:
    case GL_RED:
    case GL_GREEN:
    case GL_BLUE:
    case GL_ALPHA:
    case GL_LUMINANCE:
      size = 1;
      break;
    case GL_RGB:
    case GL_BGR:
      size = 3;
      break;
    case GL_RGBA:
    case GL_BGRA:
      size = 4;
      break;
    case GL_LUMINANCE_ALPHA:
      size = 2;
      break;
  }

  int array_type = ml_mapping_datatype_to_bigarray_type(
      glenum_ml_to_c(type));
  void* pointer = ml_malloc_array_by_datatype(
      glenum_ml_to_c(type), size);

  glReadPixels(Int_val(x), Int_val(y), Int_val(width), Int_val(height),
               glenum_ml_to_c(format),
               glenum_ml_to_c(type),
               pointer);
  barray = ml_store_array_as_type(pointer, size, array_type);
  CAMLreturn(barray);
}

t_prim gl_api_glReadPixels_bytecode(value *argv, int argc) {
  return gl_api_glReadPixels_native(
      argv[0], argv[1], argv[2], argv[3], argv[4], argv[5]);

}

t_prim gl_api_glDrawPixels(value width, value height, value format, value type, value data) {
  CAMLparam5(width, height, format, type, data);

  glDrawPixels(Int_val(width), Int_val(height),
               glenum_ml_to_c(format),
               glenum_ml_to_c(type),
               Data_bigarray_val(data));

  CAMLreturn(Val_unit);
}

t_prim gl_api_glGetTexGendv(value coord, value pname) {
  CAMLparam2(coord, pname);

  GLenum gl_pname = glenum_ml_to_c(pname);
  const int size = 4;
  double val[size];
  glGetTexGendv(glenum_ml_to_c(coord),
                gl_pname, val);
  CAMLreturn(ml_store_array_as_type(val, size, BIGARRAY_FLOAT64));
}

t_prim gl_api_glGetTexGenfv(value coord, value pname) {
  CAMLparam2(coord, pname);

  GLenum gl_pname = glenum_ml_to_c(pname);
  const int size = 4;
  float val[size];
  glGetTexGenfv(glenum_ml_to_c(coord),
                gl_pname, val);
  CAMLreturn(ml_store_array_as_type(val, size, BIGARRAY_FLOAT32));
}

t_prim gl_api_glGetTexGeniv(value coord, value pname) {
  CAMLparam2(coord, pname);

  GLenum gl_pname = glenum_ml_to_c(pname);
  const int size = 4;
  int val[size];
  glGetTexGeniv(glenum_ml_to_c(coord),
                gl_pname, val);
  CAMLreturn(ml_store_array_as_type(val, size, BIGARRAY_CAML_INT));
}

t_prim gl_api_glGetTexGenv(value coord) {
  CAMLparam1(coord);

  GLenum val;
  glGetTexGeniv(glenum_ml_to_c(coord),
                GL_TEXTURE_GEN_MODE, &val);
  CAMLreturn(glenum_c_to_ml(val));
}

t_prim gl_api_glGetTexEnvfv(value target, value pname) {
  CAMLparam2(target, pname);

  float* val = NULL;
  int size = 0;
  GLenum gl_pname = glenum_ml_to_c(pname);

  switch (gl_pname) {
    case GL_TEXTURE_ENV_COLOR:
      size = 4;
      break;
    default:
      size = 1;
      break;
  }

  val = malloc(sizeof(float) * size);
  glGetTexEnvfv(glenum_ml_to_c(target),
                gl_pname,
                val);
  value v = ml_store_array_as_type(val, size, BIGARRAY_FLOAT32);
  free(val);
  CAMLreturn(v);
}

t_prim gl_api_glGetTexEnviv(value target, value pname) {
  CAMLparam2(target, pname);

  int* val = NULL;
  int size = 0;
  GLenum gl_pname = glenum_ml_to_c(pname);

  switch (gl_pname) {
    case GL_TEXTURE_ENV_COLOR:
      size = 4;
      break;
    default:
      size = 1;
      break;
  }

  val = malloc(sizeof(int) * size);
  glGetTexEnviv(glenum_ml_to_c(target),
                gl_pname,
                val);
  value v = ml_store_array_as_type(val, size, BIGARRAY_CAML_INT);
  free(val);
  CAMLreturn(v);
}

t_prim gl_api_glGetTexLevelParameterfv(value target, value level, value pname) {
  CAMLparam3(target, level, pname);

  float v;
  glGetTexLevelParameterfv(glenum_ml_to_c(target),
                           Int_val(level),
                           glenum_ml_to_c(pname),
                           &v);

  CAMLreturn(caml_copy_double(v));
}

t_prim gl_api_glGetTexLevelParameteriv(value target, value level, value pname) {
  CAMLparam3(target, level, pname);

  int v;
  glGetTexLevelParameteriv(glenum_ml_to_c(target),
                           Int_val(level),
                           glenum_ml_to_c(pname),
                           &v);

  CAMLreturn(Val_int(v));
}

t_prim gl_api_glTexImage1D_native(value target, value level, value internal_format,
                                  value width, value border, value format, value data) {
  CAMLparam5(target, level, internal_format, width, border);
  CAMLxparam2(format, data);

  GLenum data_type = ml_camltype_to_gltype(Field(data, 0));

  glTexImage1D(glenum_ml_to_c(target),
               Int_val(level), Int_val(internal_format),
               Int_val(width), Int_val(border),
               glenum_ml_to_c(format),
               data_type, Data_bigarray_val(Field(data, 1)));
  CAMLreturn(Val_unit);
}

t_prim gl_api_glTexImage1D_bytecode(value *argv, int argc) {
  return gl_api_glTexImage1D_native(
      argv[0], argv[1], argv[2], argv[3], argv[4], argv[5], argv[6]);
}

t_prim gl_api_glTexImage2D_native(value target, value level, value internal_format,
                                  value width, value height, value border,
                                  value format, value data) {
  CAMLparam5(target, level, internal_format, width, border);
  CAMLxparam3(height, format, data);

  GLenum data_type = ml_camltype_to_gltype(Field(data, 0));

  glTexImage2D(glenum_ml_to_c(target),
               Int_val(level), Int_val(internal_format),
               Int_val(width), Int_val(height),
               Int_val(border),
               glenum_ml_to_c(format),
               data_type, Data_bigarray_val(Field(data, 1)));
  CAMLreturn(Val_unit);
}

t_prim gl_api_glTexImage2D_bytecode(value *argv, int argc) {
  return gl_api_glTexImage2D_native(
      argv[0], argv[1], argv[2], argv[3], argv[4], argv[5], argv[6], argv[7]);
}

t_prim gl_api_glTexImage3D_native(value target, value level, value internal_format,
                                  value width, value height, value depth, value border,
                                  value format, value data) {
  CAMLparam5(target, level, internal_format, width, border);
  CAMLxparam4(height, depth, format, data);

  GLenum data_type = ml_camltype_to_gltype(Field(data, 0));

  glTexImage3D(glenum_ml_to_c(target),
               Int_val(level), Int_val(internal_format),
               Int_val(width), Int_val(height), Int_val(depth),
               Int_val(border),
               glenum_ml_to_c(format),
               data_type, Data_bigarray_val(Field(data, 1)));
  CAMLreturn(Val_unit);
}

t_prim gl_api_glTexImage3D_bytecode(value *argv, int argc) {
  return gl_api_glTexImage3D_native(
      argv[0], argv[1], argv[2], argv[3], argv[4], argv[5], argv[6],
      argv[7], argv[8]);
}

t_prim gl_api_glGetTexImage(value target, value level, value format, value data) {
  CAMLparam4(target, level, format, data);

  glGetTexImage(glenum_ml_to_c(target),
                Int_val(level),
                glenum_ml_to_c(format),
                ml_camltype_to_gltype(Field(data, 0)),
                Data_bigarray_val(Field(data, 1)));
  CAMLreturn(Val_unit);
}

t_prim gl_api_glTexSubImage1D_native(value target, value level, value xoffset,
                                     value width, value format, value data) {
  CAMLparam5(target, level, xoffset, width, format);
  CAMLxparam1(data);

  GLenum data_type = ml_camltype_to_gltype(Field(data, 0));

  glTexSubImage1D(glenum_ml_to_c(target),
                  Int_val(level), Int_val(xoffset),
                  Int_val(width),
                  glenum_ml_to_c(format),
                  data_type, Data_bigarray_val(Field(data, 1)));
  CAMLreturn(Val_unit);
}

t_prim gl_api_glTexSubImage1D_bytecode(value *argv, int argc) {
  return gl_api_glTexSubImage1D_native(
      argv[0], argv[1], argv[2], argv[3], argv[4], argv[5]);
}

t_prim gl_api_glTexSubImage2D_native(value target, value level, value xoffset, value yoffset,
                                     value width, value height, value format, value data) {
  CAMLparam5(target, level, xoffset, yoffset, width);
  CAMLxparam3(height, format, data);

  GLenum data_type = ml_camltype_to_gltype(Field(data, 0));

  glTexSubImage2D(glenum_ml_to_c(target),
                  Int_val(level), Int_val(xoffset), Int_val(yoffset),
                  Int_val(width), Int_val(height),
                  glenum_ml_to_c(format),
                  data_type, Data_bigarray_val(Field(data, 1)));
  CAMLreturn(Val_unit);
}

t_prim gl_api_glTexSubImage2D_bytecode(value *argv, int argc) {
  return gl_api_glTexSubImage2D_native(
      argv[0], argv[1], argv[2], argv[3], argv[4], argv[5],
      argv[6], argv[7]);
}

t_prim gl_api_glTexSubImage3D_native(value target, value level,
                                     value xoffset, value yoffset, value zoffset,
                                     value width, value height, value depth,
                                     value format, value data) {
  CAMLparam5(target, level, xoffset, yoffset, zoffset);
  CAMLxparam5(width, height, depth, format, data);

  GLenum data_type = ml_camltype_to_gltype(Field(data, 0));

  glTexSubImage3D(glenum_ml_to_c(target),
                  Int_val(level), Int_val(xoffset), Int_val(yoffset), Int_val(zoffset),
                  Int_val(width), Int_val(height), Int_val(depth),
                  glenum_ml_to_c(format),
                  data_type, Data_bigarray_val(Field(data, 1)));
  CAMLreturn(Val_unit);
}

t_prim gl_api_glTexSubImage3D_bytecode(value *argv, int argc) {
  return gl_api_glTexSubImage3D_native(
      argv[0], argv[1], argv[2], argv[3], argv[4], argv[5],
      argv[6], argv[7], argv[8], argv[9]);
}

int ml_map_dimensions_of_target(GLenum target) {
  switch (target) {
    case GL_MAP1_COLOR_4:
    case GL_MAP1_INDEX:
    case GL_MAP1_NORMAL:
    case GL_MAP1_TEXTURE_COORD_1:
    case GL_MAP1_TEXTURE_COORD_2:
    case GL_MAP1_TEXTURE_COORD_3:
    case GL_MAP1_TEXTURE_COORD_4:
    case GL_MAP1_VERTEX_3:
    case GL_MAP1_VERTEX_4:
      return 1;
    case GL_MAP2_COLOR_4:
    case GL_MAP2_INDEX:
    case GL_MAP2_NORMAL:
    case GL_MAP2_TEXTURE_COORD_1:
    case GL_MAP2_TEXTURE_COORD_2:
    case GL_MAP2_TEXTURE_COORD_3:
    case GL_MAP2_TEXTURE_COORD_4:
    case GL_MAP2_VERTEX_3:
    case GL_MAP2_VERTEX_4:
      return 2;
  }
}

int ml_point_size_of_target(GLenum target) {
  switch (target) {
    case GL_MAP1_INDEX:
    case GL_MAP1_TEXTURE_COORD_1:
    case GL_MAP2_INDEX:
    case GL_MAP2_TEXTURE_COORD_1:
      return 1;
    case GL_MAP1_TEXTURE_COORD_2:
    case GL_MAP2_TEXTURE_COORD_2:
      return 2;
    case GL_MAP1_VERTEX_3:
    case GL_MAP1_NORMAL:
    case GL_MAP1_TEXTURE_COORD_3:
    case GL_MAP2_VERTEX_3:
    case GL_MAP2_NORMAL:
    case GL_MAP2_TEXTURE_COORD_3:
      return 3;
    case GL_MAP1_TEXTURE_COORD_4:
    case GL_MAP1_COLOR_4:
    case GL_MAP1_VERTEX_4:
    case GL_MAP2_TEXTURE_COORD_4:
    case GL_MAP2_COLOR_4:
    case GL_MAP2_VERTEX_4:
      return 4;
  }
}

int ml_calc_map_size(int orders[], int dimensions, int point_size) {
  if (dimensions == 1) {
    return orders[0] * point_size;
  } else {
    return (orders[0] * orders[1]) * point_size;
  }
}

t_prim gl_api_glGetMapdv(value target, value query) {
  CAMLparam2(target, query);

  GLenum gl_target = glenum_ml_to_c(target);
  GLenum gl_query = glenum_ml_to_c(query);

  switch (gl_query) {
    case GL_ORDER: {
      const int size = ml_map_dimensions_of_target(gl_target);
      double val[size];

      glGetMapdv(gl_target, gl_query, val);
      CAMLreturn(ml_store_array_as_type(val, size,
                                        BIGARRAY_FLOAT64));
    }
    case GL_DOMAIN: {
      const int size = ml_map_dimensions_of_target(gl_target) * 2;
      double val[size];
      glGetMapdv(gl_target, gl_query, val);
      CAMLreturn(ml_store_array_as_type(val, size,
                                        BIGARRAY_FLOAT64));
    }
    case GL_COEFF: {
      const int dimension_order = ml_map_dimensions_of_target(gl_target);
      int orders[dimension_order];
      glGetMapiv(gl_target, GL_ORDER, orders);
      const int val_size = ml_calc_map_size(orders, dimension_order,
                                            ml_point_size_of_target(gl_target));

      double *val = malloc(sizeof(double) * val_size);
      glGetMapdv(gl_target, gl_query, val);
      value retval = ml_store_array_as_type(val, val_size, BIGARRAY_FLOAT64);
      free(val);
      CAMLreturn(retval);
    }
  }
  CAMLreturn(Val_unit);
}

t_prim gl_api_glGetMapfv(value target, value query) {
  CAMLparam2(target, query);

  GLenum gl_target = glenum_ml_to_c(target);
  GLenum gl_query = glenum_ml_to_c(query);

  switch (gl_query) {
    case GL_ORDER: {
      const int size = ml_map_dimensions_of_target(gl_target);
      float val[size];

      glGetMapfv(gl_target, gl_query, val);
      CAMLreturn(ml_store_array_as_type(val, size,
                                        BIGARRAY_FLOAT32));
    }
    case GL_DOMAIN: {
      const int size = ml_map_dimensions_of_target(gl_target) * 2;
      float val[size];
      glGetMapfv(gl_target, gl_query, val);
      CAMLreturn(ml_store_array_as_type(val, size,
                                        BIGARRAY_FLOAT32));
    }
    case GL_COEFF: {
      const int dimension_order = ml_map_dimensions_of_target(gl_target);
      int orders[dimension_order];
      glGetMapiv(gl_target, GL_ORDER, orders);
      const int val_size = ml_calc_map_size(orders, dimension_order,
                                            ml_point_size_of_target(gl_target));

      float *val = malloc(sizeof(float) * val_size);
      glGetMapfv(gl_target, gl_query, val);
      value retval = ml_store_array_as_type(val, val_size, BIGARRAY_FLOAT32);
      free(val);
      CAMLreturn(retval);
    }
  }
  CAMLreturn(Val_unit);
}

t_prim gl_api_glGetMapiv(value target, value query) {
  CAMLparam2(target, query);

  GLenum gl_target = glenum_ml_to_c(target);
  GLenum gl_query = glenum_ml_to_c(query);

  switch (gl_query) {
    case GL_ORDER: {
      const int size = ml_map_dimensions_of_target(gl_target);
      int val[size];

      glGetMapiv(gl_target, gl_query, val);
      CAMLreturn(ml_store_array_as_type(val, size,
                                        BIGARRAY_CAML_INT));
    }
    case GL_DOMAIN: {
      const int size = ml_map_dimensions_of_target(gl_target) * 2;
      int val[size];
      glGetMapiv(gl_target, gl_query, val);
      CAMLreturn(ml_store_array_as_type(val, size,
                                        BIGARRAY_CAML_INT));
    }
    case GL_COEFF: {
      const int dimension_order = ml_map_dimensions_of_target(gl_target);
      int orders[dimension_order];
      glGetMapiv(gl_target, GL_ORDER, orders);
      const int val_size = ml_calc_map_size(orders, dimension_order,
                                            ml_point_size_of_target(gl_target));

      int *val = malloc(sizeof(int) * val_size);
      glGetMapiv(gl_target, gl_query, val);
      value retval = ml_store_array_as_type(val, val_size, BIGARRAY_CAML_INT);
      free(val);
      CAMLreturn(retval);
    }
  }
  CAMLreturn(Val_unit);
}

t_prim gl_api_glDrawRangeElements(value mode, value start, value end, value count, value indices) {
  CAMLparam5(mode, start, end, count, indices);

  glDrawRangeElements(glenum_ml_to_c(mode),
                      Int_val(start), Int_val(end), Int_val(count),
                      ml_camltype_to_gltype(Field(indices, 0)),
                      Data_bigarray_val(Field(indices, 1)));

  CAMLreturn(Val_unit);
}

t_prim gl_api_glColorTable(value target, value internal_format, value width,
                           value format, value data) {
  CAMLparam5(target, internal_format, width, format, data);

  glColorTable(glenum_ml_to_c(target),
               glenum_ml_to_c(internal_format),
               Int_val(width),
               glenum_ml_to_c(format),
               ml_camltype_to_gltype(Field(data, 0)),
               Data_bigarray_val(Field(data, 1)));

  CAMLreturn(Val_unit);
}

t_prim gl_api_glColorSubTable(value target, value start, value count,
                              value format, value data) {
  CAMLparam5(target, start, count, format, data);

  glColorSubTable(glenum_ml_to_c(target),
                  Int_val(start), Int_val(count),
                  glenum_ml_to_c(format),
                  ml_camltype_to_gltype(Field(data, 0)),
                  Data_bigarray_val(Field(data, 1)));

  CAMLreturn(Val_unit);
}

t_prim gl_api_glGetColorTable(value target, value format, value type, value data) {
  CAMLparam4(target, format, type, data);

  glGetColorTable(glenum_ml_to_c(target),
                  glenum_ml_to_c(format),
                  glenum_ml_to_c(type),
                  Data_bigarray_val(Field(data, 1)));

  CAMLreturn(Val_unit);
}

t_prim gl_api_glGetColorTableParameterfv(value target, value pname) {
  CAMLparam2(target, pname);

  int data_size = 0;
  switch (glenum_ml_to_c(target)) {
    case GL_COLOR_TABLE:
    case GL_POST_CONVOLUTION_COLOR_TABLE:
    case GL_POST_COLOR_MATRIX_COLOR_TABLE:
    case GL_PROXY_COLOR_TABLE:
    case GL_PROXY_POST_CONVOLUTION_COLOR_TABLE:
    case GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE: {
      switch (glenum_ml_to_c(pname)) {
        case GL_COLOR_TABLE_SCALE:
        case GL_COLOR_TABLE_BIAS:
          data_size = 4;
          break;
        default:
          data_size = 1;
          break;
      }
      break;
    }
    default:
      data_size = 1;
      break;
  }

  float *val = malloc(sizeof(float) * data_size);
  glGetColorTableParameterfv(
      glenum_ml_to_c(target),
      glenum_ml_to_c(pname),
      val);

  value retval = ml_store_array_as_type(val, data_size, BIGARRAY_FLOAT32);
  free(val);
  CAMLreturn(retval);
}

t_prim gl_api_glGetColorTableParameteriv(value target, value pname) {
  CAMLparam2(target, pname);

  int data_size = 0;
  switch (glenum_ml_to_c(target)) {
    case GL_COLOR_TABLE:
    case GL_POST_CONVOLUTION_COLOR_TABLE:
    case GL_POST_COLOR_MATRIX_COLOR_TABLE:
    case GL_PROXY_COLOR_TABLE:
    case GL_PROXY_POST_CONVOLUTION_COLOR_TABLE:
    case GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE: {
      switch (glenum_ml_to_c(pname)) {
        case GL_COLOR_TABLE_SCALE:
        case GL_COLOR_TABLE_BIAS:
          data_size = 4;
          break;
        default:
          data_size = 1;
          break;
      }
      break;
    }
    default:
      data_size = 1;
      break;
  }

  int *val = malloc(sizeof(int) * data_size);
  glGetColorTableParameteriv(
      glenum_ml_to_c(target),
      glenum_ml_to_c(pname),
      val);

  value retval = ml_store_array_as_type(val, data_size, BIGARRAY_CAML_INT);
  free(val);
  CAMLreturn(retval);
}

t_prim gl_api_glGetHistogram(value target, value reset, value format, value type,
                             value data) {
  CAMLparam5(target, reset, format, type, data);

  int gl_reset = GL_FALSE;
  if (reset == Val_true) {
    gl_reset = GL_TRUE;
  }

  glGetHistogram(glenum_ml_to_c(target),
                 gl_reset,
                 glenum_ml_to_c(format),
                 ml_camltype_to_gltype(Field(data, 0)),
                 Data_bigarray_val(Field(data, 1)));

  CAMLreturn(Val_unit);
}

t_prim gl_api_glGetHistogramParameterfv(value target, value pname) {
  CAMLparam2(target, pname);
  float val;
  glGetHistogramParameterfv(glenum_ml_to_c(target),
                            glenum_ml_to_c(pname),
                            &val);
  CAMLreturn(caml_copy_double(val));
}

t_prim gl_api_glGetHistogramParameteriv(value target, value pname) {
  CAMLparam2(target, pname);
  int val;
  glGetHistogramParameteriv(glenum_ml_to_c(target),
                            glenum_ml_to_c(pname),
                            &val);
  CAMLreturn(Val_int(val));
}

t_prim gl_api_glGetMinmax(value target, value reset, value format, value data) {
  CAMLparam4(target, reset, format, data);

  int gl_reset = GL_FALSE;
  if (reset == Val_true) {
    gl_reset = GL_TRUE;
  }

  glGetMinmax(glenum_ml_to_c(target),
              gl_reset,
              glenum_ml_to_c(format),
              ml_camltype_to_gltype(Field(data, 0)),
              Data_bigarray_val(Field(data, 1)));

  CAMLreturn(Val_unit);
}

t_prim gl_api_glGetMinmaxParameterfv(value target, value pname) {
  CAMLparam2(target, pname);

  float val;
  glGetMinmaxParameterfv(glenum_ml_to_c(target),
                         glenum_ml_to_c(pname),
                         &val);
  CAMLreturn(caml_copy_double(val));
}

t_prim gl_api_glGetMinmaxParameteriv(value target, value pname) {
  CAMLparam2(target, pname);

  int val;
  glGetMinmaxParameteriv(glenum_ml_to_c(target),
                         glenum_ml_to_c(pname),
                         &val);
  CAMLreturn(Val_int(val));
}

t_prim gl_api_glConvolutionFilter1D(value target, value internal_format,
                                    value width, value format, value data) {
  CAMLparam5(target, internal_format, width, format, data);

  glConvolutionFilter1D(glenum_ml_to_c(target),
                        glenum_ml_to_c(internal_format),
                        Int_val(width),
                        glenum_ml_to_c(format),
                        ml_camltype_to_gltype(Field(data, 0)),
                        Data_bigarray_val(Field(data, 1)));
  CAMLreturn(Val_unit);
}

t_prim gl_api_glConvolutionFilter2D_native(value target, value internal_format,
                                           value width, value height, value format, value data) {
  CAMLparam5(target, internal_format, width, format, data);
  CAMLxparam1(height);

  glConvolutionFilter2D(glenum_ml_to_c(target),
                        glenum_ml_to_c(internal_format),
                        Int_val(width), Int_val(height),
                        glenum_ml_to_c(format),
                        ml_camltype_to_gltype(Field(data, 0)),
                        Data_bigarray_val(Field(data, 1)));
  CAMLreturn(Val_unit);
}

t_prim gl_api_glConvolutionFilter2D_bytecode(value *argv, int argc) {
  return gl_api_glConvolutionFilter2D_native(
      argv[0], argv[1], argv[2], argv[3], argv[4], argv[5]);
}

t_prim gl_api_glGetConvolutionFilter(value target, value format, value data) {
  CAMLparam3(target, format, data);

  glGetConvolutionFilter(glenum_ml_to_c(target),
                         glenum_ml_to_c(format),
                         ml_camltype_to_gltype(Field(data, 0)),
                         Data_bigarray_val(Field(data, 1)));
  CAMLreturn(Val_unit);
}

t_prim gl_api_glGetConvolutionParameterfv(value target, value pname) {
  CAMLparam2(target, pname);

  int data_size = 0;
  switch (glenum_ml_to_c(pname)) {
    case GL_CONVOLUTION_BORDER_MODE:
    case GL_CONVOLUTION_FORMAT:
    case GL_CONVOLUTION_WIDTH:
    case GL_CONVOLUTION_HEIGHT:
    case GL_MAX_CONVOLUTION_WIDTH:
    case GL_MAX_CONVOLUTION_HEIGHT:
      data_size = 1;
      break;
    case GL_CONVOLUTION_BORDER_COLOR:
    case GL_CONVOLUTION_FILTER_BIAS:
      data_size = 4;
      break;
  }

  float *data = malloc(sizeof(float) * data_size);
  glGetConvolutionParameterfv(glenum_ml_to_c(target),
                              glenum_ml_to_c(pname),
                              data);
  value retval = ml_store_array_as_type(data, data_size,
                                        BIGARRAY_FLOAT32);
  free(data);
  CAMLreturn(retval);
}

t_prim gl_api_glGetConvolutionParameteriv(value target, value pname) {
  CAMLparam2(target, pname);

  int data_size = 0;
  switch (glenum_ml_to_c(pname)) {
    case GL_CONVOLUTION_BORDER_MODE:
    case GL_CONVOLUTION_FORMAT:
    case GL_CONVOLUTION_WIDTH:
    case GL_CONVOLUTION_HEIGHT:
    case GL_MAX_CONVOLUTION_WIDTH:
    case GL_MAX_CONVOLUTION_HEIGHT:
      data_size = 1;
      break;
    case GL_CONVOLUTION_BORDER_COLOR:
    case GL_CONVOLUTION_FILTER_BIAS:
      data_size = 4;
      break;
  }

  int *data = malloc(sizeof(int) * data_size);
  glGetConvolutionParameteriv(glenum_ml_to_c(target),
                              glenum_ml_to_c(pname),
                              data);
  value retval = ml_store_array_as_type(data, data_size,
                                        BIGARRAY_CAML_INT);
  free(data);
  CAMLreturn(retval);
}

t_prim gl_api_glCompressedTexImage1D_native(value target, value level,
                                            value internal_format, value width,
                                            value border, value imagesize, value data) {
  CAMLparam5(target, level, internal_format, width, border);
  CAMLxparam2(imagesize, data);

  glCompressedTexImage1D(glenum_ml_to_c(target),
                         Int_val(level),
                         glenum_ml_to_c(internal_format),
                         Int_val(width), Int_val(border),
                         Int_val(imagesize),
                         Data_bigarray_val(Field(data, 1)));
  CAMLreturn(Val_unit);
}

t_prim gl_api_glCompressedTexImage1D_bytecode(value *argv, int argc) {
  return gl_api_glCompressedTexImage1D_native(
      argv[0], argv[1], argv[2], argv[3], argv[4], argv[5], argv[6]);
}

t_prim gl_api_glCompressedTexImage2D_native(value target, value level,
                                            value internal_format, value width, value height,
                                            value border, value imagesize, value data) {
  CAMLparam5(target, level, internal_format, width, height);
  CAMLxparam3(border, imagesize, data);

  glCompressedTexImage2D(glenum_ml_to_c(target),
                         Int_val(level),
                         glenum_ml_to_c(internal_format),
                         Int_val(width), Int_val(height), Int_val(border),
                         Int_val(imagesize),
                         Data_bigarray_val(Field(data, 1)));
  CAMLreturn(Val_unit);
}

t_prim gl_api_glCompressedTexImage2D_bytecode(value *argv, int argc) {
  return gl_api_glCompressedTexImage2D_native(
      argv[0], argv[1], argv[2], argv[3], argv[4], argv[5], argv[6],
      argv[7]);
}

t_prim gl_api_glCompressedTexImage3D_native(value target, value level,
                                            value internal_format, value width, value height,
                                            value depth,
                                            value border, value imagesize, value data) {
  CAMLparam5(target, level, internal_format, width, height);
  CAMLxparam4(depth, border, imagesize, data);

  glCompressedTexImage3D(glenum_ml_to_c(target),
                         Int_val(level),
                         glenum_ml_to_c(internal_format),
                         Int_val(width), Int_val(height), Int_val(width),
                         Int_val(border), Int_val(imagesize),
                         Data_bigarray_val(Field(data, 1)));
  CAMLreturn(Val_unit);
}

t_prim gl_api_glCompressedTexImage3D_bytecode(value *argv, int argc) {
  return gl_api_glCompressedTexImage3D_native(
      argv[0], argv[1], argv[2], argv[3], argv[4], argv[5], argv[6],
      argv[7], argv[8]);
}

t_prim gl_api_glCompressedTexSubImage1D_native(value target, value level,
                                               value xoffset, value width,
                                               value format,
                                               value imagesize, value data) {
  CAMLparam5(target, level, xoffset, width, format);
  CAMLxparam2(imagesize, data);

  glCompressedTexSubImage1D(glenum_ml_to_c(target),
                            Int_val(level), Int_val(xoffset),
                            Int_val(width),
                            glenum_ml_to_c(format),
                            Int_val(imagesize),
                            Data_bigarray_val(Field(data, 1)));
  CAMLreturn(Val_unit);
}

t_prim gl_api_glCompressedTexSubImage1D_bytecode(value *argv, int argc) {
  return gl_api_glCompressedTexSubImage1D_native(
      argv[0], argv[1], argv[2], argv[3], argv[4], argv[5], argv[6]);
}

t_prim gl_api_glCompressedTexSubImage2D_native(value target, value level,
                                               value xoffset, value yoffset,
                                               value width, value height,
                                               value format,
                                               value imagesize, value data) {
  CAMLparam5(target, level, xoffset, yoffset, width);
  CAMLxparam4(height, format, imagesize, data);

  glCompressedTexSubImage2D(glenum_ml_to_c(target),
                            Int_val(level), Int_val(xoffset), Int_val(yoffset),
                            Int_val(width), Int_val(height),
                            glenum_ml_to_c(format),
                            Int_val(imagesize),
                            Data_bigarray_val(Field(data, 1)));
  CAMLreturn(Val_unit);
}

t_prim gl_api_glCompressedTexSubImage2D_bytecode(value *argv, int argc) {
  return gl_api_glCompressedTexSubImage2D_native(
      argv[0], argv[1], argv[2], argv[3], argv[4], argv[5], argv[6],
      argv[7], argv[8]);
}

t_prim gl_api_glCompressedTexSubImage3D_native(value target, value level,
                                               value xoffset, value yoffset, value zoffset,
                                               value width, value height, value depth,
                                               value format,
                                               value imagesize, value data) {
  CAMLparam5(target, level, xoffset, yoffset, zoffset);
  CAMLxparam5(width, height, depth, format, imagesize);
  CAMLxparam1(data);

  glCompressedTexSubImage3D(glenum_ml_to_c(target),
                            Int_val(level), Int_val(xoffset), Int_val(yoffset),
                            Int_val(zoffset),
                            Int_val(width), Int_val(height), Int_val(depth),
                            glenum_ml_to_c(format),
                            Int_val(imagesize),
                            Data_bigarray_val(Field(data, 1)));
  CAMLreturn(Val_unit);
}

t_prim gl_api_glCompressedTexSubImage3D_bytecode(value *argv, int argc) {
  return gl_api_glCompressedTexSubImage3D_native(
      argv[0], argv[1], argv[2], argv[3], argv[4], argv[5], argv[6],
      argv[7], argv[8], argv[9], argv[10]);
}

t_prim gl_api_glGetCompressedTexImage(value target, value lod, value data) {
  CAMLparam3(target, lod, data);

  glGetCompressedTexImage(glenum_ml_to_c(target),
                          Int_val(lod),
                          Data_bigarray_val(Field(data, 1)));
  CAMLreturn(Val_unit);
}
